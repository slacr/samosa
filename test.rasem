require 'color'

PIXEL_SIZE = 3
INPUT_FILE = "input.fasta"
COLOR_RANGE = 10
COLOR_HUE = 110
COLOR_LIGHTNESS = 35

# Open our sequence file
contents = ""
File.open(INPUT_FILE, "rb") do |file|
  contents = file.read
end


def draw_pixel(x, y, color)
  # Takes an x, y, and draws pixels  between them
  x = x * PIXEL_SIZE
  y = y * PIXEL_SIZE

  (0..PIXEL_SIZE).each do |pos_add|
    line x, y+pos_add, x+PIXEL_SIZE, y+pos_add, stroke: color
  end
end

# Make each sequence a string in sequences[] and get the max length
maxlength = 0
sequences = contents.split(/^>.*$/)
sequences = sequences.map { |seq| seq.sub("\n", "") }
sequences.each { |sequence| maxlength = sequence.length if (sequence.length >= maxlength) }
sequences.select! { |sequence| sequence.length != 0 }

# HSL object (hue,saturation,lightness) is an object representing a color.
# We'll grade down the saturation from most to least common char in the 
# distribution, using COLOR_RANGE to determine the number of intervals

# Set our maximum color to have 100% saturation
max_pair_color = Color::HSL.new(COLOR_HUE, 100, COLOR_LIGHTNESS)

# Put the color value for each interval into color_intervals[]
color_intervals = [Color::to_rgb(max_pair_color)] # Convert HSL to rgb string
(0..COLOR_RANGE-1).each do |color_interval|
  square_color = Color::HSL.new(COLOR_HUE, (100/COLOR_RANGE.ceil * color_interval), COLOR_LIGHTNESS)
  color_intervals << [Color::to_rgb(square_color)]
end
p color_intervals
exit

color_sequences = []
sequences.each do |seq|
  color_sequences << []
end

puts "Got #{sequences.length} sequences"
(0..maxlength).each do |char_pos|
  char_dist = Hash.new(0)
  sequences.each do |sequence|
    char_dist[sequence[char_pos]] += 1
  end
  # Have distribution, now find max and print those green. All others print red
  char_dist.sort_by { |key, value| value }
  max_pair = char_dist.shift
  # If the value of the second most common matches the first
  if char_dist.value? max_pair[1]
    # we have multiple tied for first place
    color_sequences.each do |color_sequence|
      # set the current char pos we're at to be grey
      color_sequence[char_pos] = color_intervals[0]
    end
  else
    sequences.each_index do |index|
      if sequences[index][char_pos] == max_pair[0]
        color_sequences[index][char_pos] = :green
      else
        color_sequences[index][char_pos] = :tomato
      end
    end
  end
end

puts color_sequences


# actually draw them
squaresize = Math.sqrt(maxlength).ceil

set_width (squaresize * (PIXEL_SIZE)) + 30
set_height (squaresize * (PIXEL_SIZE) * sequences.length) + 30

cur_x = 0
cur_y = 0

color_sequences.each do |color_sequence|
  color_sequence.each do |color_at_pos|
    draw_pixel(cur_x, cur_y, color_at_pos.to_s)
    if cur_x == squaresize
      cur_x = 0
      cur_y += 1
    else
      cur_x += 1
    end
  end
  cur_x = 0
  cur_y += 3
end
